{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"芯旺微芯片AND状态机使用指南","slug":"芯旺微22年2","date":"2022-02-27T11:26:01.000Z","updated":"2022-04-07T18:46:29.784Z","comments":true,"path":"2022/02/27/芯旺微22年2/","link":"","permalink":"http://example.com/2022/02/27/%E8%8A%AF%E6%97%BA%E5%BE%AE22%E5%B9%B42/","excerpt":"##花玖出品","text":"##花玖出品 芯旺微https://blog.csdn.net/csdnRGB/article/details/117621570 状态机https://blog.csdn.net/woody218/article/details/109409045","categories":[],"tags":[{"name":"芯旺微","slug":"芯旺微","permalink":"http://example.com/tags/%E8%8A%AF%E6%97%BA%E5%BE%AE/"}]},{"title":"键盘矩阵扫描实现","slug":"键盘矩阵扫描实现12","date":"2021-12-26T11:46:31.000Z","updated":"2022-04-07T18:45:43.667Z","comments":true,"path":"2021/12/26/键盘矩阵扫描实现12/","link":"","permalink":"http://example.com/2021/12/26/%E9%94%AE%E7%9B%98%E7%9F%A9%E9%98%B5%E6%89%AB%E6%8F%8F%E5%AE%9E%E7%8E%B012/","excerpt":"##花玖出品","text":"##花玖出品 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// PID Control program by Bill Keenan, Melbourne// Throttle PID loop stuff#define Umin -1022#define Umax 1022#define Kp 0.5 //#define Ki 0.005 //#define Kd 1.25 //float U0 = 0;float integ; // integration part of PID-loop must be saved float ep; // previous error used for differential error (e - ep) /*****************************************************************************/float prop, junk, der; // // junk, U0, Umax, Umin, Kp, Ki, err. int throttle_pidloop(int realpos) // PID-loop calc // integ - integral part of controller // ep - preceding control error // realpos - throttle position feedback // Besides this function uses global variables such as:// Kp,Ki,Kd,U0 - constants of controller;// accel_use - setpoint// Umin,Umax - range of the output control signal &#123;int output;float error; // actual control error error = (float)(accel_use - realpos); // calculation of actual error der = ((error - ep) * Kd);prop = error * Kp; // calculation of proportional part if(prop &gt; 1022) &#123; prop = 1022; &#125;if(prop &lt; -1022) &#123; prop = -1022; &#125;junk = error * Ki; // calculation of integral part integ = integ + junk; if ((int)integ &gt; Umax) &#123; integ = (float)Umax; &#125;else if ((int)integ &lt; Umin) &#123; integ = (float)Umin; &#125;output = (int)(prop + integ + der); if (output &gt; Umax) &#123; output = Umax; &#125; else if (output &lt; Umin) &#123; output = Umin; &#125;ep = error; // new error return(output); // return the object controlling magnitude &#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"步进电机控制","slug":"步进电机控制代码10","date":"2021-10-25T13:01:41.000Z","updated":"2022-04-07T18:44:56.942Z","comments":true,"path":"2021/10/25/步进电机控制代码10/","link":"","permalink":"http://example.com/2021/10/25/%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E4%BB%A3%E7%A0%8110/","excerpt":"##花玖出品","text":"##花玖出品 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457/* * IBM-PC Parallel Printer Port Data &amp; Status Registers * ==================================================== * 7 6 5 4 3 2 1 0 I/O Port * +---+---+---+---+---+---+---+---+ ======== * Data | C8| C7| C6| C5| C4| C3| C2| C1| Base = 278/378/3BC Hex * +---+---+---+---+---+---+---+---+ +---+ */#include&lt;sys/io.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt; //for floor()#include&lt;iostream&gt;using namespace std;#define BASEPORT 0x378 //SPP - Standard Parallel port base addressclass stepper&#123; private: long delay; //delay betn each step float pi; //constant float acf, lcf; //angle and length correction factors in percentage float r, c; // radius and circumerence of wheel float ns; int nfsc, nhs; float residue; // number of total steps, full step cycles and number of half steps float step_rating; //number of steps per revolution float speed; //speed of stepper in cm/sec float l,w; //length and width of robocar public: stepper(float spd); void specification(); void length2steps(float len, int&amp; nfsc, int&amp; nhs);//conversion void angle2steps(float angle, int&amp; nfsc, int&amp; nhs);//conversion void move(int nfsc, int nhs, int leftw, int rightw); //move void fwd(float len); //length in cm void bkwd(float len); //length in cm void righturn(float degree, int degree_of_freedom); //number of degree turns void lefturn(float degree, int degree_of_freedom); // -- do --&#125;;stepper:: stepper(float spd=7)&#123; speed=spd; l=18; //length of car w=17-2; //width of car acf=-2; //angle correction factor in percentage lcf=-4; //angle correction factor in percentage pi=3.14159; //costant step_rating=200.5; //step rating r=3.448; //radius of wheel in cm c=2*pi*r; //circumference residue=0; //speed being in cm/s delay=long(1/(step_rating/c*speed)*1000*1000); //in microsecond&#125;void stepper::specification()&#123; cout&lt;&lt;&quot;\\n\\n\\n\\t\\tF R O N T I E R\\n&quot;; cout&lt;&lt;&quot;\\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;; cout&lt;&lt;&quot;\\n\\n\\nDesigned by: Amit Kumar Karna&quot;; cout&lt;&lt;&quot;\\n\\n\\nMission: Vitrubio, Technozion&#x27;06 @ NIT Warangal&quot;; cout&lt;&lt;&quot;\\n\\n\\nROBOCAR specifications...&quot;; cout&lt;&lt;&quot;\\nDimensions = &quot;&lt;&lt;l&lt;&lt;&quot;cm x&quot;&lt;&lt;w&lt;&lt;&quot;cm&quot;; cout&lt;&lt;&quot;\\nWheel Dia = &quot;&lt;&lt;2*r&lt;&lt;&quot;cm&quot;; cout&lt;&lt;&quot;\\nStepper motor: 12V-0.33A \\t&quot;&lt;&lt;step_rating&lt;&lt;&quot; steps/revolution&quot;; cout&lt;&lt;&quot;\\nLength n Angle correction factors: &quot;&lt;&lt;lcf&lt;&lt;&quot;% &amp; &quot;&lt;&lt;acf&lt;&lt;&quot;% respectively&quot;; cout&lt;&lt;&quot;\\nSpeed selected : &quot;&lt;&lt;speed&lt;&lt;&quot;cm/sec&quot;; cout&lt;&lt;&quot;\\ndelay between each step = &quot;&lt;&lt;delay/1000.0&lt;&lt;&quot;ms&quot;; cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl;&#125;void stepper::length2steps(float len, int&amp; nfsc, int&amp; nhs)//conversion&#123; ns=step_rating/c*len+residue; nfsc=int(ns/4); nhs=int(floor((ns-nfsc*4)/0.5)); //rounding if(nhs==8) //may result after rounding nhs=7; residue=ns-(nfsc*4+nhs*0.5);&#125;void stepper::angle2steps(float angle, int&amp; nfsc, int&amp; nhs)//conversion&#123; float arclen=(pi*w)/360.0*angle; length2steps(arclen, nfsc, nhs);&#125;void stepper::move(int nfsc, int nhs, int leftw, int rightw) //move &#123; int i; int cnt; outb(0x00, BASEPORT); if(leftw==1 &amp;&amp; rightw==1) &#123; for(i=0; i&lt;nfsc; i++) &#123; outb(0x59, BASEPORT); usleep(delay); outb(0x6A, BASEPORT); usleep(delay); outb(0xA6, BASEPORT); usleep(delay); outb(0x95, BASEPORT); usleep(delay); if(i%50==0 &amp;&amp; i!=0) outb(0x81, BASEPORT); //one half step - as a compensation &#125; //sequence after 5 i.e. 0100 is 1 for half step //sequence after 9 i.e. 1001 is 8 for half step for(i=0; i&lt;1; i++) //dummy loop to use break; &#123; cnt=0; if(nhs==0) break; outb(0x81, BASEPORT); if(++cnt==nhs) break; outb(0xA9, BASEPORT); if(++cnt==nhs) break; outb(0x28, BASEPORT); if(++cnt==nhs) break; outb(0x6A, BASEPORT); if(++cnt==nhs) break; outb(0x42, BASEPORT); if(++cnt==nhs) break; outb(0x56, BASEPORT); if(++cnt==nhs) break; outb(0x14, BASEPORT); if(++cnt==nhs) break; //max of 7 half steps only possible &#125; &#125; else if(leftw==-1 &amp;&amp; rightw==-1) &#123; for(i=0; i&lt;nfsc; i++) &#123; outb(0x95, BASEPORT); usleep(delay); outb(0xA6, BASEPORT); usleep(delay); outb(0x6A, BASEPORT); usleep(delay); outb(0x59, BASEPORT); usleep(delay); if(i%50==0 &amp;&amp; i!=0) outb(0x81, BASEPORT); //one half step - as a compensation &#125; //sequence after 5 i.e. 0100 is 1 for half step //sequence after 9 i.e. 1001 is 8 for half step for(i=0; i&lt;1; i++) //dummy loop &#123; cnt=0; if(nhs==0) break; outb(0x81, BASEPORT); if(++cnt==nhs) break; outb(0xA9, BASEPORT); if(++cnt==nhs) break; outb(0x28, BASEPORT); if(++cnt==nhs) break; outb(0x6A, BASEPORT); if(++cnt==nhs) break; outb(0x42, BASEPORT); if(++cnt==nhs) break; outb(0x56, BASEPORT); if(++cnt==nhs) break; outb(0x14, BASEPORT); if(++cnt==nhs) break; &#125; &#125; else if(leftw==-1 &amp;&amp; rightw==1) //left turn 2 wheels &#123; for(i=0;i&lt;nfsc;i++) &#123; outb(0x99, BASEPORT); usleep(delay); outb(0xAA, BASEPORT); usleep(delay); outb(0x66, BASEPORT); usleep(delay); outb(0x55, BASEPORT); usleep(delay); &#125; //sequence after 5 i.e. 0100 is 1 for half step cnt=0; for(i=0; i&lt;1; i++) &#123; if(nhs==0) break; outb(0x11, BASEPORT); if(++cnt==nhs) break; outb(0x99, BASEPORT); if(++cnt==nhs) break; outb(0x88, BASEPORT); if(++cnt==nhs) break; outb(0xAA, BASEPORT); if(++cnt==nhs) break; outb(0x22, BASEPORT); if(++cnt==nhs) break; outb(0x66, BASEPORT); if(++cnt==nhs) break; outb(0x44, BASEPORT); if(++cnt==nhs) break; //max of 7 half steps only possible &#125; &#125; else if(leftw==1 &amp;&amp; rightw==-1) //right turn with 2 wheels &#123; for(i=0;i&lt;nfsc;i++) &#123; outb(0x55, BASEPORT); usleep(delay); outb(0x66, BASEPORT); usleep(delay); outb(0xAA, BASEPORT); usleep(delay); outb(0x99, BASEPORT); usleep(delay); &#125; //sequence after 5 i.e. 0100 is 1 for half step cnt=0; for(i=0; i&lt;1; i++) &#123; if(nhs==0) break; outb(0x44, BASEPORT); if(++cnt==nhs) break; outb(0x66, BASEPORT); if(++cnt==nhs) break; outb(0x22, BASEPORT); if(++cnt==nhs) break; outb(0xAA, BASEPORT); if(++cnt==nhs) break; outb(0x88, BASEPORT); if(++cnt==nhs) break; outb(0x99, BASEPORT); if(++cnt==nhs) break; outb(0x11, BASEPORT); if(++cnt==nhs) break; //max of 7 half steps only possible &#125; &#125; else if(leftw==0 &amp;&amp; rightw==1) //left turn with one wheel &#123; for(i=0;i&lt;nfsc;i++) &#123; outb(0x09, BASEPORT); usleep(delay); outb(0x0A, BASEPORT); usleep(delay); outb(0x06, BASEPORT); usleep(delay); outb(0x05, BASEPORT); usleep(delay); &#125; //sequence after 5 i.e. 0100 is 1 for half step cnt=0; for(i=0; i&lt;1; i++) &#123; if(nhs==0) break; outb(0x01, BASEPORT); if(++cnt==nhs) break; outb(0x09, BASEPORT); if(++cnt==nhs) break; outb(0x08, BASEPORT); if(++cnt==nhs) break; outb(0x0A, BASEPORT); if(++cnt==nhs) break; outb(0x02, BASEPORT); if(++cnt==nhs) break; outb(0x06, BASEPORT); if(++cnt==nhs) break; outb(0x04, BASEPORT); if(++cnt==nhs) break; //max of 7 half steps only possible &#125; &#125; else if(leftw==1 &amp;&amp; rightw==0) //right turn with one wheel &#123; for(i=0;i&lt;nfsc;i++) &#123; outb(0x50, BASEPORT); usleep(delay); outb(0x60, BASEPORT); usleep(delay); outb(0xA0, BASEPORT); usleep(delay); outb(0x90, BASEPORT); usleep(delay); &#125; //sequence after 5 i.e. 0100 is 1 for half step cnt=0; for(i=0; i&lt;1; i++) &#123; if(nhs==0) break; outb(0x40, BASEPORT); if(++cnt==nhs) break; outb(0x60, BASEPORT); if(++cnt==nhs) break; outb(0x20, BASEPORT); if(++cnt==nhs) break; outb(0xA0, BASEPORT); if(++cnt==nhs) break; outb(0x80, BASEPORT); if(++cnt==nhs) break; outb(0x90, BASEPORT); if(++cnt==nhs) break; outb(0x10, BASEPORT); if(++cnt==nhs) break; //max of 7 half steps only possible &#125; &#125; outb(0x00, BASEPORT);&#125; void stepper::fwd(float len=0)&#123; float tlen=len; if(len==0) return; tlen=tlen+tlen*lcf/100; length2steps(tlen, nfsc, nhs); cout&lt;&lt;&quot;\\nMoving forward by &quot;&lt;&lt;len&lt;&lt;&quot;cms... \\t[\\t&quot;&lt;&lt;nfsc&lt;&lt;&quot; &quot;&lt;&lt;nhs&lt;&lt;&quot; ]&quot;&lt;&lt;endl; move(nfsc, nhs, 1, 1);//leftw=1 &amp; rightw=1&#125;void stepper::bkwd(float len=0)&#123; float tlen=len; if(len==0) return; tlen=tlen+tlen*lcf/100; length2steps(tlen, nfsc, nhs); cout&lt;&lt;&quot;\\nMoving backward by &quot;&lt;&lt;len&lt;&lt;&quot;cms... \\t[\\t&quot;&lt;&lt;nfsc&lt;&lt;&quot; &quot;&lt;&lt;nhs&lt;&lt;&quot; ]&quot;&lt;&lt;endl; move(nfsc, nhs, -1, -1);//leftw=-1 &amp; rightw=-1&#125;void stepper::lefturn(float angle, int dof=2) //degree of freedom&#123; float tangle=angle; tangle=tangle*2/dof; tangle=tangle+tangle*acf/100; angle2steps(tangle, nfsc, nhs); cout&lt;&lt;&quot;\\nTaking left turn by &quot;&lt;&lt;angle&lt;&lt;&quot;degrees... [\\t&quot;&lt;&lt;nfsc&lt;&lt;&quot; &quot;&lt;&lt;nhs&lt;&lt;&quot; ]&quot;&lt;&lt;endl; if(dof==1) move(nfsc, nhs, 0, 1); //leftwheel=off, rightwheel=on else move(nfsc, nhs, -1, 1);&#125;void stepper::righturn(float angle, int dof=2)&#123; float tangle=angle; tangle=tangle*2/dof; tangle=tangle+tangle*acf/100; angle2steps(tangle, nfsc, nhs); cout&lt;&lt;&quot;\\nTaking right turn by &quot;&lt;&lt;angle&lt;&lt;&quot;degrees... [\\t&quot;&lt;&lt;nfsc&lt;&lt;&quot; &quot;&lt;&lt;nhs&lt;&lt;&quot; ]&quot;&lt;&lt;endl; if(dof==1) move(nfsc, nhs, 1, 0); //leftwheel=on, rightwheel=off else move(nfsc, nhs, 1, -1);&#125;main()&#123; system(&quot;clear&quot;); if(ioperm(BASEPORT,3,1)) &#123; cout&lt;&lt;&quot;\\nThe parallel port accessing error!&quot;; exit(1); &#125; float speed; //in cm/s float len, la, ra; //in cm float angle; long wait=10000; //cout&lt;&lt;&quot;\\nEnter speed in cm/s (eg. 10cm/s) : &quot;; //cin&gt;&gt;speed; speed=10; stepper sm(speed); sm.specification(); cout&lt;&lt;&quot;\\nScanning the problem...&quot;;usleep(wait); cout&lt;&lt;&quot;...&quot;;usleep(wait);cout&lt;&lt;&quot;...&quot;;usleep(wait);cout&lt;&lt;&quot;...&quot;;cout&lt;&lt;&quot;Done!&quot;; cout&lt;&lt;&quot;\\n\\n\\nStarting the voyage...\\n\\n\\n&quot;; float l1=20, l2=28.284; float a1=45, a2=90, a3=135; int i; for(i=0; i&lt;3; i++) &#123; sm.fwd(l1); usleep(wait); sm.lefturn(a3); usleep(wait); sm.fwd(l2); usleep(wait); sm.righturn(a3); &#125;&#125;","categories":[],"tags":[{"name":"MOTOR","slug":"MOTOR","permalink":"http://example.com/tags/MOTOR/"}]},{"title":"二进制表示","slug":"二进制表示9","date":"2021-09-11T12:33:31.000Z","updated":"2022-04-07T18:45:31.397Z","comments":true,"path":"2021/09/11/二进制表示9/","link":"","permalink":"http://example.com/2021/09/11/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA9/","excerpt":"##花玖出品","text":"##花玖出品 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// The following macros build values in binary. Nybbles are separated by// commas for readability. If a non-binary digit is used, a compiler error// will result. Here are some examples of the usage of the binary macros://// B4 (0110) = 0x06// B8 (0101,0101) = 0x55// B16 (1010,1010, 0101,0101) = 0xAA55// B32 (1000,0000, 1111,1111, 1010,1010, 0101,0101) = 0x80FFAA55//// For maximum readability, the bytes should be separated by spaces and there// should be no spaces between nybbles, as shown above. Note that an enum// isn&#x27;t used because MISRA-C generates errors otherwise.#define b0000 0u#define b0001 1u#define b0010 2u#define b0011 3u#define b0100 4u#define b0101 5u#define b0110 6u#define b0111 7u#define b1000 8u#define b1001 9u#define b1010 10u#define b1011 11u#define b1100 12u#define b1101 13u#define b1110 14u#define b1111 15u#pragma diag_suppress = Pm120#define B4(n0) (b##n0) //!&lt; Build a nybble in binary#pragma diag_default = Pm120#define B8(n1, n0) ((B4 (n1) &lt;&lt; 4u) | B4 (n0)) //!&lt; Build a byte in binary#define B16(n3, n2, n1, n0) \\ ((B4 (n3) &lt;&lt; 12) | (B4 (n2) &lt;&lt; 8) | (B4 (n1) &lt;&lt; 4) | B4 (n0)) //!&lt; Build a halfword in binary#define B32(n7, n6, n5, n4, n3, n2, n1, n0) \\ ((B4 (n7) &lt;&lt; 28) | (B4 (n6) &lt;&lt; 24) | (B4 (n5) &lt;&lt; 20) | (B4 (n5) &lt;&lt; 16) \\ | (B4 (n3) &lt;&lt; 12) | (B4 (n2) &lt;&lt; 8) | (B4 (n1) &lt;&lt; 4) | B4 (n0)) //!&lt; Build a word in binary#define B64(nF, nE, nD, nC, nB, nA, n9, n8, n7, n6, n5, n4, n3, n2, n1, n0) \\ ((B4 (nF) &lt;&lt; 60) | (B4 (nE) &lt;&lt; 56) | (B4 (nD) &lt;&lt; 52) | (B4 (nC) &lt;&lt; 48) \\ | (B4 (nB) &lt;&lt; 44) | (B4 (nA) &lt;&lt; 40) | (B4 (n9) &lt;&lt; 36) | (B4 (n8) &lt;&lt; 32) \\ | (B4 (n7) &lt;&lt; 28) | (B4 (n6) &lt;&lt; 24) | (B4 (n5) &lt;&lt; 20) | (B4 (n5) &lt;&lt; 16) \\ | (B4 (n3) &lt;&lt; 12) | (B4 (n2) &lt;&lt; 8) | (B4 (n1) &lt;&lt; 4) | B4 (n0)) //!&lt; Build a long in binary","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"孤儿进程、僵尸进程和守护进程","slug":"孤儿进程、僵尸进程和守护进程8","date":"2021-08-22T13:46:53.000Z","updated":"2022-04-08T15:36:22.640Z","comments":true,"path":"2021/08/22/孤儿进程、僵尸进程和守护进程8/","link":"","permalink":"http://example.com/2021/08/22/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B8/","excerpt":"##花玖出品","text":"##花玖出品 基本概念1. 孤儿进程：当父进程退出后他的子进程还在运行，那么这些子进程就是孤儿进程。孤儿进程将被init进程所养，并由init进程对他们完成状态收集工作。 2. 僵尸进程：当子进程退出后而父进程并未接收结束子进程（如调用waipid获取子进程的状态信息），那么子进程仍停留在系统中，这就是僵尸进程。 3. 守护进程：是指在后台运行不受终端控制的进程（如输入、输出等）。网络服务大部分就是守护进程 如何创建守护进程1. 创建子进程，父进程推出：因为守护进程是在后台不受终端所控制的进程，父进程退出后控制台就以为该程序结束了，我们就可以在子进程进行自己的任务，同时用户仍可以在控制台输入指令，从而在形式上做到了与控制台脱离。 2. 在子进程中创建新的会话（脱离控制终端）：使用系统函数setid()来创建一个新的会话，并担任该会话组组长，摆脱原会话的控制==&gt;摆脱原进程的控制==&gt;摆脱原控制台的控制 3. 改变当前目录为根目录：子进程继承父进程的目录信息，但进程运行时对当前目录下的文件系统不能卸载，这会有很多隐藏的麻烦，建议使用根目录作为当前目录，当然也可以使用其他目录。 4. 重设文件权限掩码，关闭文件描述符：子进程还继承父进程的文件权限掩码，即屏蔽掉文件权限中的对应位。此时子进程需将其重置为0，即在此时有很大的权限，从而提高该守护进程灵活度。最后，关系从父进程继承的已经打开的文件描述符，如不进行关闭将造成浪费资源以及进程所有文件系统无法卸载等错误。 正确处理孤儿进程、僵尸进程的方法1. 孤儿进程的处理:孤儿进程就是没有父进程的进程，它的处理就由进程为1 的Init进程负责，就像一个福利院一样，专门负责孤儿。当有孤儿进程需要处理的时候，系统就把孤儿进程的父进程设置为init，而init进程会循环的wait（）它的已经退出的子进程。因此，孤儿进程不处理也不会有什么危害。 2. 僵尸进程的处理：如果父进程一直不调用wait/waitpid函数接收子进程，那么子进程就一直保存在系统当中，占用系统资源，如果僵尸进程太多，那么就会导致系统空间爆满，无法创建新的进程，严重影响系统工作，为此僵尸进程需要好好处理。正确处理：系统规定，子进程退出后，父进程会自动收到SIGCHLD信号。因此我们需要父进程中重置signal函数。每当子进程退出，父进程就会收到SIGCHIL信号，故通过signal函数，重置信号响应函数。","categories":[],"tags":[{"name":"进程/线程","slug":"进程-线程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"}]},{"title":"PID 功能实现","slug":"PID功能实现","date":"2021-06-06T11:11:21.000Z","updated":"2022-04-07T18:44:44.366Z","comments":true,"path":"2021/06/06/PID功能实现/","link":"","permalink":"http://example.com/2021/06/06/PID%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","excerpt":"##花玖出品","text":"##花玖出品 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*! \\details This structure holds the data to run a * floating point PID loop. */typedef struct&#123; float max /*! \\brief Max manipulated value */; float min /*! \\brief Miniumum manipulated value */; float e /*! \\brief Error value */; float i /*! \\brief Integrator value */; float kp /*! \\brief Proportional constant */; float ki /*! \\brief Integrator constant */; float kd /*! \\brief Differential constant */;&#125; pid_f_t;/*! \\details This function initializes the data in a PID structure. * */void pid_init_f(pid_f_t * ptr /*! A pointer to the PID data structure */, float min /*! The manipulated variable&#x27;s minimum value */, float max /*! The manipulated variable&#x27;s maximum value */)&#123; memset(ptr, 0, sizeof(pid_f_t)); ptr-&gt;min = min; ptr-&gt;max = max;&#125;/*! \\details This function updates the value of the manipulated variable (MV) * based on the current state of the PID loop. */float pid_update_f(float sp /*! The set point */, float pv /*! The process variable */, pid_f_t * ptr /*! A pointer to the PID constants */)&#123; float temp; float e; float p; float manp; float tmpi; //get the error from the last call e = ptr-&gt;e; //calculate the new error (set point - present value) ptr-&gt;e = sp - pv; //use a temp variable for the integrator tmpi = ptr-&gt;i + ptr-&gt;e; //update the manipulated process variable manp = ptr-&gt;kp * ptr-&gt;e + ptr-&gt;ki * tmpi + ptr-&gt;kd * (ptr-&gt;e - e); //the integrator is only updated if the manipulated process is within range //otherwise the system will likely become unstable if ( (manp &lt; ptr-&gt;max) &amp;&amp; (manp &gt; ptr-&gt;min) )&#123; ptr-&gt;i = tmpi; &#125; else if ( manp &gt; ptr-&gt;max )&#123; manp = ptr-&gt;max; &#125; else if ( manp &lt; ptr-&gt;min )&#123; manp = ptr-&gt;min; &#125; return manp;&#125;","categories":[],"tags":[{"name":"PID","slug":"PID","permalink":"http://example.com/tags/PID/"}]},{"title":"嵌入式C语言注意事项","slug":"嵌入式C语言注意事项5","date":"2021-05-23T10:56:01.000Z","updated":"2022-04-07T18:46:01.906Z","comments":true,"path":"2021/05/23/嵌入式C语言注意事项5/","link":"","permalink":"http://example.com/2021/05/23/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B95/","excerpt":"##花玖出品","text":"##花玖出品 Volatilevolatile易变的，可变的，一般用于以下几种状况： 1）并行设备的硬件寄存器（如：状态寄存器） 2）一个中断服务子程序中会访问到的非自动变量（Non-automatic variables) 3）多线程应用中被几个任务共享的变量 volatile可以解决用户模式和异常中断访问同一个变量时，出现的不同步问题，另外在访问硬件地址时，volatile也阻止对地址访问的优化，从而确保访问的实际的地址，精通volatile的运用，在嵌入式底层中十分重要，也是嵌入式C从业者的基本要求之一。函数指针在一般嵌入式软件的开发中并不常见，但对许多重要的实现如异步回调，驱动模块，使用函数指针就可以利用简单的方式实现很多应用 C语言的结构体支持指针和变量的方式访问，通过转换可以解析任意内存的数据(如我们之前提到的通过指针强制转换解析协议)，另外通过将数据和函数指针打包，在通过指针传递，是实现驱动层实接口切换的重要基础，有着重要的实践意义，另外基于位域，联合体，结构体，可以实现另一种位操作，这对于封装底层硬件寄存器具有重要意义，实践如下： 12345678910111213141516171819202122232425typedef unsigned char uint8_t; union reg&#123; struct&#123; uint8_t bit0:1; uint8_t bit1:1; uint8_t bit2_6:5; uint8_t bit7:1; &#125;bit; uint8_t all; &#125;; int main(void)&#123; union reg RegData; RegData.all = 0; RegData.bit.bit0 = 1; RegData.bit.bit7 = 1; printf(&quot;0x%x\\n&quot;, RegData.all); RegData.bit.bit2_6 = 0x3; printf(&quot;0x%x\\n&quot;, RegData.all); &#125; /* 0x81 0x8d*/ 预处理#if..#elif…#else…#endif， #ifdef..#endif, #ifndef…#endif条件选择判断，条件选择主要用于切换代码块，这种综合性项目和跨平台项目中为了满足多种情况下的需求往往会被使用。 #undef 取消定义的参数，避免重定义问题。 #error，#warning用于用户自定义的告警信息，配合#if，#ifdef使用，可以限制错误的预定义配置。 #pragma 带参数的预定义处理，常见的#pragma pack(1), 不过使用后会导致后续的整个文件都以设置的字节对齐，配合push和pop可以解决这种问题，代码如下： 12345678910111213#pragma pack(push)#pragma pack(1)struct TestA&#123; char i; int b;&#125;A;#pragma pack(pop); //注意要调用pop，否则会导致后续文件都以pack定义值对齐，执行不符合预期等同于 struct _TestB&#123; char i; int b; &#125;__attribute__((packed))A;","categories":[],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"常用到的数据转换","slug":"常用数据转换","date":"2021-05-06T09:33:21.000Z","updated":"2022-04-07T18:45:16.699Z","comments":true,"path":"2021/05/06/常用数据转换/","link":"","permalink":"http://example.com/2021/05/06/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/","excerpt":"##花玖出品","text":"##花玖出品 1. 字符串转hex123456789101112131415161718192021void StrToHex(char *pbDest, char *pbSrc, int nLen)&#123; char h1,h2; char s1,s2; int i; for (i=0; i&lt;nLen/2; i++) &#123; h1 = pbSrc[2*i]; h2 = pbSrc[2*i+1]; s1 = toupper(h1) - 0x30; //toupper 转换为大写字母 if (s1 &gt; 9) s1 -= 7; s2 = toupper(h2) - 0x30; if (s2 &gt; 9) s2 -= 7; pbDest[i] = s1*16 + s2; &#125;&#125; 2. 十进制转字符串1234567891011u16 DectoStr (u8 *pSrc, u16 SrcLen, u8 *pObj)&#123; u16 i=0; for(i=0; i&lt;SrcLen; i++) &#123; sprintf((char *)(pObj + i * 2), &quot;%02d&quot;, *(pSrc + i)); &#125; *(pObj + i * 2) = &#x27;\\0&#x27;; return (i * 2);&#125; 3. u32转u8数组1234567void U32ToU8Array(uint8_t *buf, uint32_t u32Value)&#123; buf[0] = ((u32Value &gt;&gt; 24) &amp; 0xFF); buf[1] = ((u32Value &gt;&gt; 16) &amp; 0xFF); buf[2] = ((u32Value &gt;&gt; 8) &amp; 0xFF); buf[3] = (u32Value &amp; 0xFF);&#125; 4. u8转u32数组1234void U8ArrayToU32(uint8_t *buf, uint32_t *u32Value)&#123; *u32Value = (buf[0] &lt;&lt;24) + (buf[1] &lt;&lt;16) + (buf[2] &lt;&lt;8) + (buf[3] &lt;&lt;0);&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"hexo发生error:spawn failed解决办法","slug":"HexoErrorSpawnFailed","date":"2021-03-05T06:32:34.000Z","updated":"2022-04-07T17:50:24.836Z","comments":true,"path":"2021/03/05/HexoErrorSpawnFailed/","link":"","permalink":"http://example.com/2021/03/05/HexoErrorSpawnFailed/","excerpt":"##花玖出品","text":"##花玖出品 问题描述 出现错误描述error：spawn failed… 界面下方继续展示的内容会有以下问题fatal: cannot lock ref ‘HEAD’: unable to resolve reference HEAD: Invalid argument error: src refspec 或者：error: src refspec HEAD does not match any.等等 问题总结此类问题大多是由于git进行push或者hexo d的时候改变了一些 .deploy_git 文件下的内容解决办法 删除 .deploy_git 文件夹 输入git config --global core.autocrlf false 然后依次执行： hexo clean hexo g hexo d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"C变量必须初始化","slug":"C变量初始化","date":"2021-02-20T11:15:31.000Z","updated":"2022-04-10T16:07:44.682Z","comments":true,"path":"2021/02/20/C变量初始化/","link":"","permalink":"http://example.com/2021/02/20/C%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"##花玖出品","text":"##花玖出品 数字初始化0，字符初始化为’\\0’, 字符串和指针初始化为NULL； “不完全初始化”和“完全不初始化”不一样。如果“完全不初始化”，即只定义“int a[5]；”而不初始化，那么各个元素的值就不是0了，所有元素都是垃圾值。 也不能写成“int a[5]={}；”。如果大括号中什么都不写，那就是极其严重的语法错误。大括号中最少要写一个数。比如“int a[5]={0}；”，这时就是给数组“清零”，此时数组中每个元素都是零。 C数组初始化详解:https://m.php.cn/article/480445.html","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"如何发现代码中混入了中文字符","slug":"C语言如何判断出现中文字符","date":"2021-01-11T06:32:34.000Z","updated":"2022-04-10T16:02:09.284Z","comments":true,"path":"2021/01/11/C语言如何判断出现中文字符/","link":"","permalink":"http://example.com/2021/01/11/C%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6/","excerpt":"##花玖出品","text":"##花玖出品 问题描述 编译报的错误是”unknown character ‘0x..’”,一般就说明混入了中文字符问题总结此类问题大多是由于敲入了中文的分号，逗号等解决办法 编写代码前提前看一下输入法的设置","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]}],"categories":[],"tags":[{"name":"芯旺微","slug":"芯旺微","permalink":"http://example.com/tags/%E8%8A%AF%E6%97%BA%E5%BE%AE/"},{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"MOTOR","slug":"MOTOR","permalink":"http://example.com/tags/MOTOR/"},{"name":"进程/线程","slug":"进程-线程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"},{"name":"PID","slug":"PID","permalink":"http://example.com/tags/PID/"},{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}